#pragma once
#include <algorithm>
#include <queue>
#include <vector>
#include "Wierzcholek.h"

std::vector<int> dfs(std::vector<Wierzcholek>& graf, int start_index = 3) {
    int n = graf.size();
    if (n == 0) return {};

    std::vector<bool> visited(n, false);
    std::vector<int> res;

    std::cout << "Wykonano DFS" << std::endl;

    // Używamy priority_queue z greater<int> aby najmniejsze elementy były na wierzchu
    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;
    pq.push(start_index);

    while (!pq.empty()) {
        int node = pq.top();
        pq.pop();

        if (visited[node]) continue;

        visited[node] = true;
        res.push_back(node);

        std::vector<int> neigh = graf[node].pobierzSasiadow();

        sort(neigh.begin(), neigh.end());

        for (int v : neigh) {
            if (!visited[v]) {
                pq.push(v);
            }
        }
    }

    return res;
}